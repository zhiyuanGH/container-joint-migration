package main

import (
	"context"
	"fmt"
	"io"
	"os"
	"os/exec"
	"os/signal"
	// "path/filepath"
	"syscall"
	"time"

	"github.com/docker/docker/api/types/container"
	"github.com/docker/docker/api/types/image"
	"github.com/docker/docker/api/types/checkpoint"
	"github.com/docker/docker/client"
)

func main() {
	// Create a Docker client
	cli, err := client.NewClientWithOpts(client.FromEnv, client.WithAPIVersionNegotiation())
	if err != nil {
		panic(err)
	}

	ctx := context.Background()

	// Pull the busybox image
	reader, err := cli.ImagePull(ctx, "busybox", image.PullOptions{})
	if err != nil {
		panic(err)
	}
	io.Copy(os.Stdout, reader)

	// Create and start the initial container
	resp, err := cli.ContainerCreate(ctx, &container.Config{
		Image: "busybox",
		Cmd:   []string{"sh", "-c", "i=0; while true; do echo $i; i=$((i+1)); sleep 1; done"},
		Tty:   false,
	}, nil, nil, nil, "")
	if err != nil {
		panic(err)
	}

	if err := cli.ContainerStart(ctx, resp.ID, container.StartOptions{}); err != nil {
		panic(err)
	}

	// Fetch the logs of the container
	out, err := cli.ContainerLogs(ctx, resp.ID, container.LogsOptions{ShowStdout: true, Follow: true})
	if err != nil {
		panic(err)
	}

	// Function to print container logs
	printLogs := func(out io.ReadCloser) {
		if _, err := io.Copy(os.Stdout, out); err != nil {
			panic(err)
		}
	}

	go printLogs(out)

	// Schedule checkpoint and restore
	go func() {
		time.Sleep(5 * time.Second)
		fmt.Println("Checkpointing container...")
		if err := cli.CheckpointCreate(ctx, resp.ID, checkpoint.CreateOptions{CheckpointID: "checkpoint1", Exit: true}); err != nil {
			panic(err)
		}
		fmt.Println("Container checkpointed.")

		time.Sleep(6 * time.Second)
		fmt.Println("Migrating container...")
		newContainerID := createAndRestoreContainer(ctx, cli, resp.ID, "checkpoint1")

		// Fetch the logs of the restored container
		out, err := cli.ContainerLogs(ctx, newContainerID, container.LogsOptions{ShowStdout: true, Follow: true})
		if err != nil {
			panic(err)
		}
		go printLogs(out)
	}()

	// Wait for a signal to stop the container
	fmt.Println("Press Ctrl+C to stop the container...")

	// Handle interrupt signals to properly stop the container
	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, syscall.SIGINT, syscall.SIGTERM)
	<-sigChan

	// Stop the container
	if err := cli.ContainerStop(ctx, resp.ID, container.StopOptions{}); err != nil {
		panic(err)
	}

	fmt.Println("Container stopped.")
}

// createAndRestoreContainer creates a new container and restores it from the specified checkpoint
func createAndRestoreContainer(ctx context.Context, cli *client.Client, originalContainerID, checkpointID string) string {
	// Create a new container with the same configuration
	newResp, err := cli.ContainerCreate(ctx, &container.Config{
		Image: "busybox",
		Cmd:   []string{"sh", "-c", "i=0; while true; do echo $i; i=$((i+1)); sleep 1; done"},
		Tty:   false,
	}, nil, nil, nil, "")
	if err != nil {
		panic(err)
	}

	// Define checkpoint paths
	originalCheckpointDir := fmt.Sprintf("/var/lib/docker/containers/%s/checkpoints/%s", originalContainerID, checkpointID)
	newCheckpointDir := fmt.Sprintf("/var/lib/docker/containers/%s/checkpoints/%s", newResp.ID, checkpointID)

	// Create the destination checkpoint directory

	// Copy the checkpoint files from the original container to the new container
	cmd := exec.Command("cp", "-r", originalCheckpointDir, newCheckpointDir)
	if err := cmd.Run(); err != nil {
		panic(err)
	}

	// Restore the new container from the checkpoint
	if err := cli.ContainerStart(ctx, newResp.ID, container.StartOptions{CheckpointID: checkpointID}); err != nil {
		panic(err)
	}

	fmt.Println("New container restored from checkpoint:", newResp.ID)
	return newResp.ID
}
