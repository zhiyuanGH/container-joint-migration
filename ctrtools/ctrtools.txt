package ctrtools
import (
	"context"
	"fmt"

	"github.com/containerd/containerd"
	"github.com/containerd/containerd/errdefs"
)

// PruneContainers prunes all containers, including running ones
func PruneContainers(ctx context.Context, client *containerd.Client) error {
	containers, err := client.Containers(ctx)
	if err != nil {
		return err
	}

	for _, container := range containers {
		fmt.Printf("Processing container: %s\n", container.ID())
		task, err := container.Task(ctx, nil)
		if err != nil {
			if errdefs.IsNotFound(err) {
				// Task not found, no need to kill or delete the task
				fmt.Printf("Task not found for container: %s\n", container.ID())
				if err := container.Delete(ctx, containerd.WithSnapshotCleanup); err != nil {
					fmt.Printf("Failed to delete container %s: %v\n", container.ID(), err)
					return err
				}
				fmt.Printf("Pruned container: %s\n", container.ID())
				continue
			}
			return err
		}

		// Print task information for debugging
		// fmt.Printf("Task info for container %s: %+v\n", container.ID(), task)

		// Check if the task is running before killing it
		status, err := task.Status(ctx)
		if err != nil {
			return err
		}

		// Print task status for debugging
		// fmt.Printf("Task status for container %s: %s\n", container.ID(), status.Status)

		if status.Status != containerd.Running {
			// Task is not running, no need to kill it
			// fmt.Printf("Task for container %s is not running (status: %s)\n", container.ID(), status.Status)
		} else {
			// Kill the task
			if err := task.Kill(ctx, 9); err != nil {
				fmt.Printf("Failed to kill task for container %s: %v\n", container.ID(), err)
				return err
			}

			// Wait for the task to stop
			exitStatusC, err := task.Wait(ctx)
			if err != nil {
				fmt.Printf("Failed to wait for task to stop for container %s: %v\n", container.ID(), err)
				return err
			}
			<-exitStatusC

			// Delete the task
			if _, err := task.Delete(ctx, containerd.WithProcessKill); err != nil {
				fmt.Printf("Failed to delete task for container %s: %v\n", container.ID(), err)
				return err
			}
		}

		// Delete the container
		if err := container.Delete(ctx, containerd.WithSnapshotCleanup); err != nil {
			if errdefs.IsFailedPrecondition(err) {
				fmt.Printf("Failed to delete container %s: task is still running\n", container.ID())
				continue
			}
			fmt.Printf("Failed to delete container %s: %v\n", container.ID(), err)
			return err
		}

		fmt.Printf("Pruned container: %s\n", container.ID())
	}

	return nil
}

// PruneImages prunes all images
func PruneImages(ctx context.Context, client *containerd.Client) error {
	images, err := client.ListImages(ctx)
	if (err != nil) {
		return err
	}

	for _, image := range images {
		if err := client.ImageService().Delete(ctx, image.Name()); err != nil {
			return err
		}

		fmt.Printf("Pruned image: %s\n", image.Name())
	}

	return nil
}