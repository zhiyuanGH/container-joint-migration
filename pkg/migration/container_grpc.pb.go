// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v3.12.4
// source: proto/container.proto

package migration

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ContainerMigrationClient is the client API for ContainerMigration service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ContainerMigrationClient interface {
	CheckpointContainer(ctx context.Context, in *CheckpointRequest, opts ...grpc.CallOption) (*CheckpointResponse, error)
	TransferVolume(ctx context.Context, in *VolumeRequest, opts ...grpc.CallOption) (*VolumeResponse, error)
	TransferContainerInfo(ctx context.Context, in *ContainerInfoRequest, opts ...grpc.CallOption) (*ContainerInfoResponse, error)
}

type containerMigrationClient struct {
	cc grpc.ClientConnInterface
}

func NewContainerMigrationClient(cc grpc.ClientConnInterface) ContainerMigrationClient {
	return &containerMigrationClient{cc}
}

func (c *containerMigrationClient) CheckpointContainer(ctx context.Context, in *CheckpointRequest, opts ...grpc.CallOption) (*CheckpointResponse, error) {
	out := new(CheckpointResponse)
	err := c.cc.Invoke(ctx, "/migration.ContainerMigration/CheckpointContainer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerMigrationClient) TransferVolume(ctx context.Context, in *VolumeRequest, opts ...grpc.CallOption) (*VolumeResponse, error) {
	out := new(VolumeResponse)
	err := c.cc.Invoke(ctx, "/migration.ContainerMigration/TransferVolume", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *containerMigrationClient) TransferContainerInfo(ctx context.Context, in *ContainerInfoRequest, opts ...grpc.CallOption) (*ContainerInfoResponse, error) {
	out := new(ContainerInfoResponse)
	err := c.cc.Invoke(ctx, "/migration.ContainerMigration/TransferContainerInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ContainerMigrationServer is the server API for ContainerMigration service.
// All implementations must embed UnimplementedContainerMigrationServer
// for forward compatibility
type ContainerMigrationServer interface {
	CheckpointContainer(context.Context, *CheckpointRequest) (*CheckpointResponse, error)
	TransferVolume(context.Context, *VolumeRequest) (*VolumeResponse, error)
	TransferContainerInfo(context.Context, *ContainerInfoRequest) (*ContainerInfoResponse, error)
	mustEmbedUnimplementedContainerMigrationServer()
}

// UnimplementedContainerMigrationServer must be embedded to have forward compatible implementations.
type UnimplementedContainerMigrationServer struct {
}

func (UnimplementedContainerMigrationServer) CheckpointContainer(context.Context, *CheckpointRequest) (*CheckpointResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckpointContainer not implemented")
}
func (UnimplementedContainerMigrationServer) TransferVolume(context.Context, *VolumeRequest) (*VolumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferVolume not implemented")
}
func (UnimplementedContainerMigrationServer) TransferContainerInfo(context.Context, *ContainerInfoRequest) (*ContainerInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TransferContainerInfo not implemented")
}
func (UnimplementedContainerMigrationServer) mustEmbedUnimplementedContainerMigrationServer() {}

// UnsafeContainerMigrationServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ContainerMigrationServer will
// result in compilation errors.
type UnsafeContainerMigrationServer interface {
	mustEmbedUnimplementedContainerMigrationServer()
}

func RegisterContainerMigrationServer(s grpc.ServiceRegistrar, srv ContainerMigrationServer) {
	s.RegisterService(&ContainerMigration_ServiceDesc, srv)
}

func _ContainerMigration_CheckpointContainer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckpointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerMigrationServer).CheckpointContainer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/migration.ContainerMigration/CheckpointContainer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerMigrationServer).CheckpointContainer(ctx, req.(*CheckpointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerMigration_TransferVolume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VolumeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerMigrationServer).TransferVolume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/migration.ContainerMigration/TransferVolume",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerMigrationServer).TransferVolume(ctx, req.(*VolumeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ContainerMigration_TransferContainerInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContainerInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ContainerMigrationServer).TransferContainerInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/migration.ContainerMigration/TransferContainerInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ContainerMigrationServer).TransferContainerInfo(ctx, req.(*ContainerInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ContainerMigration_ServiceDesc is the grpc.ServiceDesc for ContainerMigration service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ContainerMigration_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "migration.ContainerMigration",
	HandlerType: (*ContainerMigrationServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CheckpointContainer",
			Handler:    _ContainerMigration_CheckpointContainer_Handler,
		},
		{
			MethodName: "TransferVolume",
			Handler:    _ContainerMigration_TransferVolume_Handler,
		},
		{
			MethodName: "TransferContainerInfo",
			Handler:    _ContainerMigration_TransferContainerInfo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/container.proto",
}

// PullContainerClient is the client API for PullContainer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PullContainerClient interface {
	PullContainer(ctx context.Context, in *PullRequest, opts ...grpc.CallOption) (*PullResponse, error)
}

type pullContainerClient struct {
	cc grpc.ClientConnInterface
}

func NewPullContainerClient(cc grpc.ClientConnInterface) PullContainerClient {
	return &pullContainerClient{cc}
}

func (c *pullContainerClient) PullContainer(ctx context.Context, in *PullRequest, opts ...grpc.CallOption) (*PullResponse, error) {
	out := new(PullResponse)
	err := c.cc.Invoke(ctx, "/migration.PullContainer/PullContainer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PullContainerServer is the server API for PullContainer service.
// All implementations must embed UnimplementedPullContainerServer
// for forward compatibility
type PullContainerServer interface {
	PullContainer(context.Context, *PullRequest) (*PullResponse, error)
	mustEmbedUnimplementedPullContainerServer()
}

// UnimplementedPullContainerServer must be embedded to have forward compatible implementations.
type UnimplementedPullContainerServer struct {
}

func (UnimplementedPullContainerServer) PullContainer(context.Context, *PullRequest) (*PullResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PullContainer not implemented")
}
func (UnimplementedPullContainerServer) mustEmbedUnimplementedPullContainerServer() {}

// UnsafePullContainerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PullContainerServer will
// result in compilation errors.
type UnsafePullContainerServer interface {
	mustEmbedUnimplementedPullContainerServer()
}

func RegisterPullContainerServer(s grpc.ServiceRegistrar, srv PullContainerServer) {
	s.RegisterService(&PullContainer_ServiceDesc, srv)
}

func _PullContainer_PullContainer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PullRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PullContainerServer).PullContainer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/migration.PullContainer/PullContainer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PullContainerServer).PullContainer(ctx, req.(*PullRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PullContainer_ServiceDesc is the grpc.ServiceDesc for PullContainer service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PullContainer_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "migration.PullContainer",
	HandlerType: (*PullContainerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "PullContainer",
			Handler:    _PullContainer_PullContainer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/container.proto",
}

// RecordFClient is the client API for RecordF service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RecordFClient interface {
	RecordFReset(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*RecordResponse, error)
}

type recordFClient struct {
	cc grpc.ClientConnInterface
}

func NewRecordFClient(cc grpc.ClientConnInterface) RecordFClient {
	return &recordFClient{cc}
}

func (c *recordFClient) RecordFReset(ctx context.Context, in *RecordRequest, opts ...grpc.CallOption) (*RecordResponse, error) {
	out := new(RecordResponse)
	err := c.cc.Invoke(ctx, "/migration.RecordF/RecordFReset", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RecordFServer is the server API for RecordF service.
// All implementations must embed UnimplementedRecordFServer
// for forward compatibility
type RecordFServer interface {
	RecordFReset(context.Context, *RecordRequest) (*RecordResponse, error)
	mustEmbedUnimplementedRecordFServer()
}

// UnimplementedRecordFServer must be embedded to have forward compatible implementations.
type UnimplementedRecordFServer struct {
}

func (UnimplementedRecordFServer) RecordFReset(context.Context, *RecordRequest) (*RecordResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecordFReset not implemented")
}
func (UnimplementedRecordFServer) mustEmbedUnimplementedRecordFServer() {}

// UnsafeRecordFServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RecordFServer will
// result in compilation errors.
type UnsafeRecordFServer interface {
	mustEmbedUnimplementedRecordFServer()
}

func RegisterRecordFServer(s grpc.ServiceRegistrar, srv RecordFServer) {
	s.RegisterService(&RecordF_ServiceDesc, srv)
}

func _RecordF_RecordFReset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecordRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RecordFServer).RecordFReset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/migration.RecordF/RecordFReset",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RecordFServer).RecordFReset(ctx, req.(*RecordRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RecordF_ServiceDesc is the grpc.ServiceDesc for RecordF service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RecordF_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "migration.RecordF",
	HandlerType: (*RecordFServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RecordFReset",
			Handler:    _RecordF_RecordFReset_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/container.proto",
}
